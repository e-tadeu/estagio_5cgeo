# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProjetosEstagio5CGEO
                                 A QGIS plugin
 Solução dos Estagiarios do 5 CGEO
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-04
        copyright            : (C) 2023 by Estagiarios 5 CGEO
        emails               : e.tadeu.eb@ime.eb.br
                               joao.pereira@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Estagiarios do 5 CGEO'
__date__ = '2023-04-04'
__copyright__ = '(C) 2023 by Estagiarios 5 CGEO'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
import os
import concurrent.futures
from collections import defaultdict
import processing
from processing.tools import dataobjects
from itertools import combinations, tee
from typing import Iterable, List
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsField,
    QgsProcessingParameterFeatureSink,
    QgsProcessingException,
    QgsFeature,
    QgsGeometry,
    QgsFields,
    QgsFeatureSink,
    QgsExpression,
    QgsWkbTypes,
    QgsProject,
    QgsFeatureRequest,
    QgsProcessingParameterField,
    QgsProcessingParameterVectorLayer,
    QgsProcessingMultiStepFeedback,
    QgsProcessingFeatureSourceDefinition,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterDistance,
    QgsProcessingParameterMultipleLayers,
    QgsSpatialIndex,
)
from qgis.PyQt.QtCore import QVariant
import math


class Projeto2Solucao(QgsProcessingAlgorithm): #NÃO ALTERE O NOME "PROJETO2SOLUCAO"

    INPUT = "INPUT"
    SELECTED = "SELECTED"
    ATTRIBUTE_BLACK_LIST = "ATTRIBUTE_BLACK_LIST"
    IGNORE_VIRTUAL_FIELDS = "IGNORE_VIRTUAL_FIELDS"
    IGNORE_PK_FIELDS = "IGNORE_PK_FIELDS"
    POINT_FILTER_LAYERS = "POINT_FILTER_LAYERS"
    LINE_FILTER_LAYERS = "LINE_FILTER_LAYERS"
    FLAGS = "FLAGS"


    def initAlgorithm(self, config):
        """
        Parameter setting.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT,
                self.tr("Input layer"),
                [
                    QgsProcessing.TypeVectorLine,
                ],
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.SELECTED, self.tr("Process only selected features")
            )
        )
        self.addParameter(
            QgsProcessingParameterField(
                self.ATTRIBUTE_BLACK_LIST,
                self.tr("Fields to ignore"),
                None,
                "INPUT",
                QgsProcessingParameterField.Any,
                allowMultiple=True,
                optional=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IGNORE_VIRTUAL_FIELDS,
                self.tr("Ignore virtual fields"),
                defaultValue=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IGNORE_PK_FIELDS,
                self.tr("Ignore primary key fields"),
                defaultValue=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.POINT_FILTER_LAYERS,
                self.tr("Point Filter Layers"),
                QgsProcessing.TypeVectorPoint,
                optional=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.LINE_FILTER_LAYERS,
                self.tr("Line Filter Layers"),
                QgsProcessing.TypeVectorLine,
                optional=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.FLAGS, self.tr("{0} Flags").format(self.displayName())
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        inputLyr = self.parameterAsVectorLayer(parameters, self.INPUT, context)
        onlySelected = self.parameterAsBoolean(parameters, self.SELECTED, context)
        pointFilterLyrList = self.parameterAsLayerList(
            parameters, self.POINT_FILTER_LAYERS, context
        )
        lineFilterLyrList = self.parameterAsLayerList(
            parameters, self.LINE_FILTER_LAYERS, context
        )
        self.prepareFlagSink(parameters, inputLyr, QgsWkbTypes.Point, context)
        if inputLyr is None:
            return {"FLAGS": self.flag_id}
        attributeBlackList = self.parameterAsFields(
            parameters, self.ATTRIBUTE_BLACK_LIST, context
        )
        fieldList = self.layerHandler.getAttributesFromBlackList(
            inputLyr,
            attributeBlackList,
            ignoreVirtualFields=self.parameterAsBoolean(
                parameters, self.IGNORE_VIRTUAL_FIELDS, context
            ),
            excludePrimaryKeys=self.parameterAsBoolean(
                parameters, self.IGNORE_PK_FIELDS, context
            ),
        )
        fieldIdList = [
            i for i, field in enumerate(inputLyr.fields()) if field.name() in fieldList
        ]
        multiStepFeedback = QgsProcessingMultiStepFeedback(6, feedback)
        multiStepFeedback.setCurrentStep(0)
        multiStepFeedback.setProgressText(self.tr("Building local cache..."))
        localLyr = self.runAddAutoIncrementalField(
            inputLyr=inputLyr
            if not onlySelected
            else QgsProcessingFeatureSourceDefinition(inputLyr.id(), True),
            fieldName="AUTO",
            context=context,
            feedback=multiStepFeedback,
        )
        multiStepFeedback.setCurrentStep(1)
        multiStepFeedback.setProgressText(
            self.tr("Building initial and end point dict...")
        )
        initialAndEndPointDict = self.buildInitialAndEndPointDict(
            localLyr, context=context, feedback=multiStepFeedback
        )
        multiStepFeedback.setProgressText(self.tr("Building aux structure..."))
        multiStepFeedback.setCurrentStep(2)
        mergedPointLyr = (
            self.runMergeVectorLayers(pointFilterLyrList, context, multiStepFeedback)
            if pointFilterLyrList
            else None
        )
        multiStepFeedback.setCurrentStep(3)
        mergedLineLyr = (
            self.runMergeVectorLayers(lineFilterLyrList, context, multiStepFeedback)
            if lineFilterLyrList
            else None
        )
        multiStepFeedback.setCurrentStep(4)
        if mergedLineLyr is not None:
            self.runCreateSpatialIndex(mergedLineLyr, context, multiStepFeedback)
        dictSize = len(initialAndEndPointDict)
        if dictSize == 0:
            return {"FLAGS": self.flag_id}
        filterPointSet = (
            set(i.geometry().asWkb() for i in mergedPointLyr.getFeatures())
            if mergedPointLyr is not None
            else set()
        )
        multiStepFeedback.setCurrentStep(5)
        multiStepFeedback.setProgressText(self.tr("Evaluating candidates"))
        self.evaluateFlagCandidates(
            fieldList,
            fieldIdList,
            multiStepFeedback,
            localLyr,
            initialAndEndPointDict,
            mergedLineLyr,
            dictSize,
            filterPointSet,
        )
        return {"FLAGS": self.flag_id}

    def evaluateFlagCandidates(
        self,
        fieldList,
        fieldIdList,
        multiStepFeedback,
        localLyr,
        initialAndEndPointDict,
        mergedLineLyr,
        dictSize,
        filterPointSet,
    ):
        stepSize = 100 / dictSize
        multiStepFeedback = QgsProcessingMultiStepFeedback(2, multiStepFeedback)
        multiStepFeedback.setCurrentStep(0)

        def evaluate(pointXY, idSet):
            if multiStepFeedback.isCanceled():
                return None
            geom = QgsGeometry.fromPointXY(pointXY)
            geomWkb = geom.asWkb()
            if geomWkb in filterPointSet:
                return None
            if len(idSet) != 2:
                return None
            if mergedLineLyr is not None:
                bbox = geom.boundingBox()
                nIntersects = len(
                    [
                        i
                        for i in mergedLineLyr.getFeatures(bbox)
                        if i.geometry().intersects(geom)
                    ]
                )
                if nIntersects > 0:
                    return None
            request = (
                QgsFeatureRequest()
                .setFilterExpression(f"AUTO in {tuple(idSet)}")
                .setFlags(QgsFeatureRequest.NoGeometry)
                .setSubsetOfAttributes(fieldIdList)
            )
            f1, f2 = [i for i in localLyr.getFeatures(request)]
            differentFeats = any(f1[k] != f2[k] for k in fieldList)
            return geomWkb if not differentFeats else None

        pool = concurrent.futures.ThreadPoolExecutor(max_workers=os.cpu_count() - 1)
        futures = set()

        for current, (pointXY, idSet) in enumerate(initialAndEndPointDict.items()):
            if multiStepFeedback.isCanceled():
                break
            futures.add(pool.submit(evaluate, pointXY, idSet))
            multiStepFeedback.setProgress(current * stepSize)

        multiStepFeedback.setCurrentStep(1)
        for current, future in enumerate(concurrent.futures.as_completed(futures)):
            if multiStepFeedback.isCanceled():
                break
            geomWkb = future.result()
            if geomWkb is not None:
                self.flagFeature(
                    flagGeom=geomWkb,
                    flagText=self.tr("Not merged lines with same attribute set"),
                    fromWkb=True,
                )
            multiStepFeedback.setProgress(current * stepSize)

    def buildInitialAndEndPointDict(self, lyr, algRunner, context, feedback):
        pointDict = defaultdict(set)
        nSteps = 3
        currentStep = 0
        multiStepFeedback = QgsProcessingMultiStepFeedback(nSteps, feedback)
        multiStepFeedback.setCurrentStep(currentStep)
        boundaryLyr = algRunner.runBoundary(
            inputLayer=lyr, context=context, feedback=multiStepFeedback
        )
        currentStep += 1
        multiStepFeedback.setCurrentStep(currentStep)
        boundaryLyr = algRunner.runMultipartToSingleParts(
            inputLayer=boundaryLyr, context=context, feedback=multiStepFeedback
        )
        currentStep += 1

        multiStepFeedback.setCurrentStep(currentStep)
        featCount = boundaryLyr.featureCount()
        if featCount == 0:
            return pointDict
        step = 100 / featCount
        for current, feat in enumerate(boundaryLyr.getFeatures()):
            if multiStepFeedback.isCanceled():
                break
            geom = feat.geometry()
            if geom is None or not geom.isGeosValid():
                continue
            id = feat["AUTO"]
            pointList = geom.asMultiPoint() if geom.isMultipart() else [geom.asPoint()]
            for point in pointList:
                pointDict[point].add(id)
            multiStepFeedback.setProgress(current * step)
        return pointDict

    def prepareFlagSink(self, parameters, source, wkbType, context, addFeatId=False):
        (self.flagSink, self.flag_id) = self.prepareAndReturnFlagSink(
            parameters, source, wkbType, context, self.FLAGS, addFeatId=addFeatId
        )

    def prepareAndReturnFlagSink(
        self, parameters, source, wkbType, context, UI_FIELD, addFeatId=False
    ):
        flagFields = self.getFlagFields(addFeatId=addFeatId)
        (flagSink, flag_id) = self.parameterAsSink(
            parameters,
            UI_FIELD,
            context,
            flagFields,
            wkbType,
            source.sourceCrs() if source is not None else QgsProject.instance().crs(),
        )
        if flagSink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, UI_FIELD))
        return (flagSink, flag_id)

    def getFlagFields(self, addFeatId=False):
        fields = QgsFields()
        fields.append(QgsField("reason", QVariant.String))
        if addFeatId:
            fields.append(QgsField("featid", QVariant.String))
        return fields

    def flagFeature(self, flagGeom, flagText, featid=None, fromWkb=False, sink=None):
        """
        Creates and adds to flagSink a new flag with the reason.
        :param flagGeom: (QgsGeometry) geometry of the flag;
        :param flagText: (string) Text of the flag
        """
        flagSink = self.flagSink if sink is None else sink
        newFeat = QgsFeature(self.getFlagFields(addFeatId=featid is not None))
        newFeat["reason"] = flagText
        if featid is not None:
            newFeat["featid"] = featid
        if fromWkb:
            geom = QgsGeometry()
            geom.fromWkb(flagGeom)
            newFeat.setGeometry(geom)
        else:
            newFeat.setGeometry(flagGeom)
        flagSink.addFeature(newFeat, QgsFeatureSink.FastInsert)

    def runAddAutoIncrementalField(
        self,
        inputLyr,
        context,
        feedback=None,
        outputLyr=None,
        fieldName=None,
        start=1,
        sortAscending=True,
        sortNullsFirst=False,
        is_child_algorithm=False,
    ):
        fieldName = "featid" if fieldName is None else fieldName
        outputLyr = "memory:" if outputLyr is None else outputLyr
        parameters = {
            "INPUT": inputLyr,
            "FIELD_NAME": fieldName,
            "START": start,
            "GROUP_FIELDS": [],
            "SORT_EXPRESSION": "",
            "SORT_ASCENDING": sortAscending,
            "SORT_NULLS_FIRST": sortNullsFirst,
            "OUTPUT": outputLyr,
        }
        output = processing.run(
            "native:addautoincrementalfield",
            parameters,
            context=context,
            feedback=feedback,
            is_child_algorithm=is_child_algorithm,
        )
        return output["OUTPUT"]

    def runMultipartToSingleParts(
        self,
        inputLayer,
        context,
        feedback=None,
        outputLyr=None,
        is_child_algorithm=False,
    ):
        outputLyr = "memory:" if outputLyr is None else outputLyr
        parameters = {"INPUT": inputLayer, "OUTPUT": outputLyr}
        output = processing.run(
            "native:multiparttosingleparts",
            parameters,
            context=context,
            feedback=feedback,
            is_child_algorithm=is_child_algorithm,
        )
        return output["OUTPUT"]

    def runMergeVectorLayers(
        self, inputList, context, feedback=None, outputLyr=None, crs=None
    ):
        outputLyr = "memory:" if outputLyr is None else outputLyr
        parameters = {"LAYERS": inputList, "CRS": crs, "OUTPUT": outputLyr}
        output = processing.run(
            "native:mergevectorlayers", parameters, context=context, feedback=feedback
        )
        return output["OUTPUT"]

    def runCreateSpatialIndex(
        self, inputLyr, context, feedback=None, is_child_algorithm=False
    ):
        processing.run(
            "native:createspatialindex",
            {"INPUT": inputLyr},
            feedback=feedback,
            context=context,
            is_child_algorithm=is_child_algorithm,
        )


    def name(self):
        return "identifica_linhas_conectadas_com_mesmo_conjunto_de_atributos"

    def displayName(self):
        return (
            "Identificar linhas conectadas com mesmo conjunto de atributos"
        )

    def group(self):
        return "Projeto 2"
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Projeto2Solucao()
